### 정렬 알고리즘(Sorting algorithm)
  - 버블 정렬
  - 선택 정렬
  - 삽입 정렬
  - 퀵 정렬
  - 병합 정렬
  - 힙 정렬
  - 셀 정렬
    
### 동적 계획법(Dynamic Programming)
    - 전체 문제를 여러 개의 하위 문제로 나눠 풀고, 하위 문제들의 해결 방법을 결합하여 최종 문제를 해결하는 문제 해결 방식
    - 모든 방법을 검토하여 최적의 해를 찾아내는 방식
  - 메모제이션(memoization) : 한 번 계산된 결과를 저장해 두웠다가 사용하여 중복 계산을 줄이는 방식
    - 구현 방식 
      - Top-down : 큰 문제를 작은 문제로 나눠 작은 문제를 풀고 큰 문제를 푼다(재귀)
      - Bottom-up : 작은 문제부터 문제의 크기를 늘려가며 문제를 푼다(반복문)
  - ex) 피보나치 수열
  - ex) LIS(Longest increasing subsequence) - 가장 긴 증가 부분 수열

### 탐욕적 기법(Greedy algorithm)
    - 문제를 해결하는 과정에서 순간마다 최적이라고 판단한 방식으로 진행하여 최종 답에 도달하는 문제 해결 방식
  - DP가 모든 가능성 계산, Greedy는 순간순간 최적의 해 선택 ⇒ 서로 보완하는 개념
  - 해결 방법은 아래 두 조건이 성립되어야 잘 작동
    - 탐욕스러운 선택 조건 : 앞의 선택이 이후의 선택에 영향을 주지 않는 조건
    - 최적 부분 구조 조건 : 문제에 대한 최종 해결 방법이 부분 문제에 대해서도 또한 최적 문제 해결 방법인 조건
  - 장점 : 다른 최적해 계산 알고리즘에 비해 빠른 속도로 계산
  - 단점 : 순간의 최적 해를 찾기 때문에 항상 최적 해를 찾는 것은 불가능
  - ex) 동전 문제, 도시락 문제

### 다익스트라 알고리즘(Dijkstra algorithm)
    - 음의 가중치가 없는 그래프의 한 정점에서 모든 정점까지의 최단거리를 각각 구하는 알고리즘
  1. 출발점으로부터 최단거리를 저장할 배열 d[]을 만들고, 출발노드에는 0, 나머지 노드들에는 매우 큰 값 INF를 넣는다(무한으로 간주될 수 있는 값).
  2. dis[A][B]는 A와 B사이의 거리 / 현재 노드를 나타내는 A에 출발 노드 번호 입력
  3. d[A] + dis[A][B] 와 d[B]의 값을 비교해 작은 값을 d[B]에 갱신
  4. A의 모든 이웃 노드에 대해 3번 수행한 뒤 A는 방문 완료 상태
  5. 미방문 상태인 노드 중 출발 노드로투버 거리가 제일 짧은 노드를 골라 A에 갱신
  6. 미방문 노드를 선택할 수 없을 때 까지 3~5번 과정 반복
  - 우선순위 큐를 사용해 minHeap방식을 활용해 가장 짧은 거리를 가진 노드 정보를 먼저 꺼낼 수 있음
